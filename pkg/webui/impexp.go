package webui

import (
	"bytes"
	"encoding/json"
	"github.com/go-macaron/binding"
	"github.com/toni-moreno/snmpcollector/pkg/data/impexp"
	"gopkg.in/macaron.v1"
	"io/ioutil"
	"mime/multipart"
	"os"
	"strconv"
	"time"
)

type UploadForm struct {
	AutoRename bool
	ExportFile *multipart.FileHeader
}

func NewImportExport(m *macaron.Macaron) error {

	bind := binding.Bind

	m.Group("/api/cfg/export", func() {
		m.Get("/:objtype/:id", reqSignedIn, ExportObject)
		m.Post("/:objtype/:id", reqSignedIn, bind(impexp.ExportInfo{}), ExportObjectToFile)

	})
	m.Group("/api/cfg/import", func() {
		m.Post("/", reqSignedIn, binding.MultipartForm(UploadForm{}), ImportDataFile)
	})
	return nil
}

/****************/
/*IMPORT*/
/*****************/

type ImportCheck struct {
	Info       *impexp.ExportInfo
	IsOk       bool
	Message    string
	Duplicated []*impexp.ExportObject
}

func ImportDataFile(ctx *Context, uf UploadForm) {
	if (UploadForm{}) == uf {
		log.Error("Error no data in expected struct")
		ctx.JSON(404, "Error no data in expected struct")
		return
	}
	log.Debugf("Uploaded data :%+v", uf)
	if uf.ExportFile == nil {
		ctx.JSON(404, "Error no file uploaded struct")
		return
	}
	log.Debugf("Uploaded File : %+v", uf)
	file, err := uf.ExportFile.Open()
	if err != nil {
		log.Warningf("Error on Open Uploaded File: %s", err)
		ctx.JSON(404, err.Error())
	}
	buf := new(bytes.Buffer)
	buf.ReadFrom(file)
	s := buf.String()
	log.Debug("FILE DATA: %s", s)
	ImportedData := impexp.ExportData{}
	if err := json.Unmarshal(buf.Bytes(), &ImportedData); err != nil {
		log.Errorf("Error in data to struct (json-unmarshal) procces: %s", err)
		ctx.JSON(404, err.Error())
	}
	log.Debugf("IMPORTED STRUCT %+v", ImportedData)

	arrays, err := ImportedData.ImportCheck()

	if err != nil && uf.AutoRename == false {
		ctx.JSON(200, &ImportCheck{Info: ImportedData.Info, IsOk: false, Message: err.Error(), Duplicated: arrays})
		return
	}
	if err != nil && uf.AutoRename == true {
		timestamp := time.Now().Unix()
		replaced := buf.Bytes()
		for _, v := range arrays {
			oldid := v.ObjectID
			newid := v.ObjectID + "_" + strconv.FormatInt(timestamp, 10)
			log.Debugf("replacind old ID %s for new one %s", oldid, newid)
			replaced = bytes.Replace(replaced, []byte(oldid), []byte(newid), -1)
		}
		ImportedData = impexp.ExportData{}
		if err = json.Unmarshal(replaced, &ImportedData); err != nil {
			log.Errorf("Error in data to struct (json-unmarshal) procces: %s", err)
			ctx.JSON(404, err.Error())
		}
		err = ImportedData.Import()
		if err != nil {
			log.Errorf("Some Error happened on import data: %s", err)
			ctx.JSON(404, err.Error())
		}
		ctx.JSON(200, &ImportCheck{Info: ImportedData.Info, IsOk: true, Message: "all duplicated ID's have been replaced", Duplicated: arrays})
		return
	}
	err = ImportedData.Import()
	if err != nil {
		log.Errorf("Some Error happened on import data: %s", err)
		ctx.JSON(404, err.Error())
	}
	ctx.JSON(200, &ImportCheck{Info: ImportedData.Info, IsOk: true, Message: "all objects have been  imported", Duplicated: nil})
}

/****************/
/*EXPORT*/
/****************/

func ExportObject(ctx *Context) {
	id := ctx.Params(":id")
	objtype := ctx.Params(":objtype")
	exp := impexp.NewExport(&impexp.ExportInfo{FileName: "autogenerated.txt", Description: "autogenerated"})
	err := exp.Export(objtype, id)
	if err != nil {
		log.Warningf("Error on get object array for type %s with ID %s  , error: %s", objtype, id, err)
		ctx.JSON(404, err.Error())
	} else {
		ctx.JSON(200, &exp)
	}
}

func ExportObjectToFile(ctx *Context, info impexp.ExportInfo) {

	id := ctx.Params(":id")
	objtype := ctx.Params(":objtype")
	exp := impexp.NewExport(&info)
	err := exp.Export(objtype, id)
	if err != nil {
		log.Errorf("Error on create Export Data with: %s", err)
		ctx.JSON(404, err.Error())
		return
	}
	outdata, err := json.Marshal(exp)
	if err != nil {
		log.Errorf("Error on Json data formatting: %s", err)
		ctx.JSON(404, err.Error())
		return
	}
	tmpfile, err := ioutil.TempFile("", "snmpcollector")
	if err != nil {
		log.Errorf("Error on create new temporal file: %s", err)
		ctx.JSON(404, err.Error())
		return
	}
	defer os.Remove(tmpfile.Name())
	if _, err := tmpfile.Write(outdata); err != nil {
		log.Errorf("Error on write data to temporal file: %s", tmpfile.Name())
		ctx.JSON(404, err.Error())
		return
	}
	if err := tmpfile.Close(); err != nil {
		log.Errorf("Error on close temporal file: %s", tmpfile.Name())
		ctx.JSON(404, err.Error())
		return
	}

	ctx.ServeFile(tmpfile.Name())
}
